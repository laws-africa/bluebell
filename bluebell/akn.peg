grammar akn
  # TODO: either one big grammar, or we need to fake inheritance

  root              <- 'noop'

  # ------------------------------------------------------------------------------
  # Judgment
  # ------------------------------------------------------------------------------ 

  judgment          <- judgment_body
                       conclusions:conclusions?
                       attachments:attachments?
                       <Judgment>

  judgment_body     <- introduction:introduction?
                       background:background?
                       arguments:arguments?
                       remedies:remedies?
                       motivation:motivation?
                       decision:decision?
                       <JudgmentBody>

  # ------------------------------------------------------------------------------ 
  # Hierarchical Structure (acts, bills)
  # ------------------------------------------------------------------------------
  # TODO: coverpage

  act               <- hierarchical_structure <Act>

  bill              <- hierarchical_structure <Bill>

  hierarchical_structure <- preface:preface?
                            preamble:preamble?
                            body
                            conclusions:conclusions?
                            attachments:attachments?
                            <HierarchicalStructure>

  # ------------------------------------------------------------------------------
  # Open structure (doc, statement, debateReport, etc.)
  # ------------------------------------------------------------------------------

  debate_report     <- open_structure <DebateReport>

  doc               <- open_structure <Doc>

  statement         <- open_structure <Statement>

  # TODO: components
  open_structure    <- preface:preface?
                       preamble:preamble?
                       main_body
                       conclusions:conclusions?
                       attachments:attachments?
                       <OpenStructure>

  # ------------------------------------------------------------------------------
  # Hierarchical elements
  # ------------------------------------------------------------------------------

  hier_element      <- crossheading / hier_element_block

  hier_element_block <- hier_element_name heading:hier_element_heading? eol
                        indent
                          subheading:subheading?
                          content:hier_block_element*
                        dedent <HierElement>

                        # num - heading
                        # - heading
                        # num
                        # TODO: maybe better to make the heading the default?
                        #   eg: heading
                        #       num -
                        #       num - heading
  hier_element_heading <- space num:[^\n-]* heading:('-' space content:inline*)? <HierElementHeading>

  hier_block_element <- hier_element / block_element

                     # this is for top-level containers that may/may not start with an
                     # indented block, but otherwise contain hier content
  hier_indent       <- (indent content:hier_element+ dedent) / hier_element

                     # this is for top-level containers that may/may not start with an
                     # indented block, but otherwise contain block and hier content
  hier_block_indent <- (indent content:hier_block_element+ dedent) / hier_block_element

                     # synonyms that are prefixes of other items must come last
  hier_element_name <- ('ALINEA' / 'ARTICLE' / 'BOOK' / 'CHAPTER' / 'CLAUSE' / 'DIVISION' / 'INDENT' / 'LEVEL' / 'LIST'
                        / 'PARAGRAPH' / 'PART' / 'POINT' / 'PROVISO' / 'RULE' / 'SECTION' / 'SUBCHAPTER'
                        / 'SUBCLAUSE' / 'SUBDIVISION' / 'SUBLIST' / 'SUBPARAGRAPH' / 'SUBPART' / 'SUBRULE'
                        / 'SUBSECTION' / 'SUBTITLE' / 'TITLE' / 'TOME' / 'TRANSITIONAL'
                        / 'ART' / 'CHAP' / 'PARA' / 'SEC' / 'SUBCHAP' / 'SUBPARA' / 'SUBSEC')

  # ------------------------------------------------------------------------------
  # Containers
  # ------------------------------------------------------------------------------

  preface           <- preface_marker
                       content:(!preamble_marker !body_marker block_element)*
                       <Preface>

  preamble          <- preamble_marker
                       content:(!body_marker block_element)*
                       <Preamble>

                     # body that MUST have a hier element
  body              <- body_marker?
                       content:(!conclusions_marker !attachment_marker hier_block_indent)*
                       <Body>

                     # body with mixed block and hier elements
  main_body         <- body_marker?
                       content:(!conclusions_marker !attachment_marker hier_block_indent)*
                       <MainBody>

  conclusions       <- conclusions_marker
                       content:(!attachment_marker block_element)*
                       <Conclusions>

  # Judment-specific containers

  introduction      <- introduction_marker
                       content:(!background_marker !arguments_marker !remedies_marker !motivation_marker !decision_marker !conclusions_marker !attachment_marker hier_block_indent)*
                       <Introduction>

  background        <- background_marker
                       content:(!arguments_marker !remedies_marker !motivation_marker !decision_marker !conclusions_marker !attachment_marker hier_block_indent)*
                       <Background>

  arguments         <- arguments_marker?
                       content:(!remedies_marker !motivation_marker !decision_marker !conclusions_marker !attachment_marker hier_block_indent)*
                       <Arguments>

  remedies          <- remedies_marker
                       content:(!motivation_marker !decision_marker !conclusions_marker !attachment_marker hier_block_indent)*
                       <Remedies>

  motivation        <- motivation_marker
                       content:(!decision_marker !conclusions_marker !attachment_marker hier_block_indent)*
                       <Motivation>

  decision          <- decision_marker
                       content:(!conclusions_marker !attachment_marker hier_block_indent)*
                       <Decision>

  attachments       <- attachment+ <Attachments>

                       # an attachment's body may be indented with a subheading, or go
                       # directly into content, or a mixture
  attachment        <- attachment_marker heading:attachment_heading? eol
                       indented:(
                         indent
                           subheading:subheading?
                           content:hier_block_element*
                         dedent
                       )?
                       content:(!attachment_marker hier_block_indent)*
                       <Attachment>

  attachment_heading <- space content:inline* <AttachmentHeading>

  # General container markers

  body_marker       <- 'BODY' eol

  conclusions_marker <- 'CONCLUSIONS' eol

  preamble_marker   <- 'PREAMBLE' eol

  preface_marker    <- 'PREFACE' eol

  # Judgment markers

  introduction_marker <- 'INTRODUCTION' eol

  background_marker <- 'BACKGROUND' eol

  arguments_marker  <- 'ARGUMENTS' eol

  remedies_marker   <- 'REMEDIES' eol

  motivation_marker <- 'MOTIVATION' eol

  decision_marker   <- 'DECISION' eol

  # attachment markers

  attachment_marker <- 'ATTACHMENT' / 'APPENDIX' / 'SCHEDULE' / 'ANNEXURE'

  # ------------------------------------------------------------------------------ 
  # Blocks
  # ------------------------------------------------------------------------------

                     # optionally nested block element
  block_element     <- nested_block_element / block_elements

  nested_block_element <- indent content:block_element+ dedent <NestedBlockElement>

  block_elements    <- block_list / table / longtitle / footnote / block_quote / line

  longtitle         <- 'LONGTITLE' space content:inline+ eol <Longtitle>

  subheading        <- 'SUBHEADING' space content:inline+ eol <Heading>

  crossheading      <- 'CROSSHEADING' space content:inline+ eol <Crossheading>

                     # The line block is the only thing that can contain arbitrary text
                     # at the start of a line, where a dedent may occur. By guarding
                     # against it, we don't have to guard at every place that
                     # could start a line.
  line              <- !dedent content:inline+ eol <Line>

  # ------------------------------------------------------------------------------
  # Block lists
  #
  # BLOCKLIST
  #   intro
  #
  #   ITEM (a) - heading
  #     SUBHEADING subhead
  #
  #     block content
  #
  #   wrapup
  # ------------------------------------------------------------------------------

  block_list        <- ('BLOCKLIST' / 'ITEMS') attrs:block_attrs? eol
                       indent
                         intro:block_list_intro?
                         items:block_list_item+
                         wrapup:block_list_wrapup?
                       dedent <BlockList>

                     # A blocklist can only have one line each of list introduction and wrapup, but
                     # we need to be able to support a line of text and footnotes.
  block_list_intro  <- !'ITEM' line footnotes:footnote* <BlockListIntro>

  block_list_wrapup <- line footnotes:footnote* <BlockListWrapUp>

  block_list_item   <- 'ITEM' heading:hier_element_heading? eol
                       content:(indent
                         subheading:subheading?
                         children:block_element+
                       dedent)?
                       <BlockListItem>

  # ------------------------------------------------------------------------------
  # Tables
  #
  # TABLE
  #   TR
  #     TH{colspan 2}
  #       text
  #
  #     TD{rowspan 3|colspan 1}
  #       text
  # ------------------------------------------------------------------------------

  table             <- 'TABLE' attrs:block_attrs? eol
                       indent
                         rows:table_row+
                       dedent <Table>

  table_row         <- 'TR' eol
                       indent
                         cells:table_cell+
                       dedent <TableRow>

  table_cell        <- name:('TH' / 'TC') attrs:block_attrs? eol
                       content:(indent
                         content:block_element+
                       dedent)? <TableCell>

  block_attrs       <- '{' first:block_attr? space? rest:('|' space? attr:block_attr?)* '}' <BlockAttrs>

  block_attr        <- attr_name value:(space attr_value)? <BlockAttr>

  attr_name         <- [^ \n|{}]+

  attr_value        <- [^\n|}]*

  # ------------------------------------------------------------------------------
  # Subflows (that go from inlines into nested complex structures)
  # ------------------------------------------------------------------------------

  block_quote       <- 'QUOTE' attrs:block_attrs? eol
                        indent
                          content:hier_block_element+
                        dedent
                        <BlockQuote>

  footnote          <- 'FOOTNOTE' space marker:([^ \n]+) space? eol
                       indent
                         content:hier_block_element+
                       dedent
                       <Footnote>

  # ------------------------------------------------------------------------------ 
  # Inlines and markers
  # ------------------------------------------------------------------------------ 

  # inlines that are not nested, and so we don't need to be careful of the closing }}
  inline            <- non_inline_start / escape / inline_marker / [^\n] <InlineText>

  # match as much text as possible that isn't potentially a special inline or escape marker.
  #
  # !!! NB: Every non-special character goes through this rule and so it's heavily used.
  #         The code generated for this rule is customised by Parser in parser.py
  #         in order to greatly improve its performance. If this regex changes, it MUST
  #         also be updated in Parser.NON_INLINE_START_RE.
  non_inline_start  <- [^*/_{[\n\\]+

  # inlines that ARE nested, and so we must guard against the closing }}
  inline_nested     <- [^*/_{[\n\\}]+ / escape / (!'}}' inline_marker / [^\n]) <InlineText>

  # inline remarks are the only inline that have a unique closing marker: ]]
  inline_end_remark <- [^*/_{[\n\]\\]+ / escape / (!']]' inline_marker / [^\n]) <InlineText>

  inline_marker     <- bold / image / italics / underline / sup / sub / remark / ref / footnote_ref

  # escape anything with a single backslash (double here because it needs to be escaped itself)
  escape            <- '\\' [^\n]

  # special case inlines that can't logically contain themselves, and so their openers and closers are symmetric

                     # **foo**
  bold              <- '**' content:(!'**' inline)+ '**' <Bold>

                     # //foo//
  italics           <- '//' content:(!'//' inline)+ '//' <Italics>

                     # __foo__
  underline         <- '__' content:(!'__' inline)+ '__' <Underline>

                     # [[remark]]
  remark            <- '[[' content:(!']]' inline_nested:inline_end_remark)+ ']]' <Remark>

  # generic-style inlines: {{...}}

                     # {{IMG src description}}
  image             <- inline_open 'IMG' space? href:(!inline_close [^ \n])+ content:(!inline_close [^\n])* inline_close <Image>

                     # {{^foo}}
  sup               <- inline_open '^' content:(!inline_close inline_nested)+ inline_close <Sup>

                     # {{_foo}}
  sub               <- inline_open '_' content:(!inline_close inline_nested)+ inline_close <Sub>

                     # {{>href text}}
  ref               <- inline_open '>' href:(!inline_close [^ \n])* ' '? content:(!inline_close inline_nested)* inline_close <Ref>

                     # {{FOOTNOTE 9}}
  footnote_ref      <- inline_open 'FOOTNOTE' space marker:(!inline_close [^\n])+ inline_close <FootnoteRef>

  inline_open       <- '{{'

  inline_close      <- '}}'

  # ------------------------------------------------------------------------------
  # Terminals
  # ------------------------------------------------------------------------------ 

  eol               <- newline empty_line*

  empty_line        <- newline

  space             <- ' '+

  newline           <- "\n"

  indent            <- '{' eol

  dedent            <- '}' eol
