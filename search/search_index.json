{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bluebell","text":"<p>Bluebell is both a markup language format and a library for parsing that format into/from Akoma Ntoso XML. It is created and maintaned by Laws.Africa.</p> <p>Bluebell converts the highly structured Bluebell text format into valid Akoma Ntoso 3 XML. Its syntax works a bit like Markdown but is purpose-built for AKN: editors use keywords to indicate hierarchical elements (chapters, parts, sections, subsections), block elements (lists, crossheadings) and inline elements (bold, italics, references). The parser turns that input into valid Akoma Ntoso XML, even when the input is imperfect.</p> <p>Bluebell can also unparse Akoma Ntoso XML back into Bluebell text, enabling round-tripping workflows for editing and publishing.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Supports Akoma Ntoso root types: acts and bills (hierarchicalStructure), judgments, debate reports/docs/statements   (openStructure), and debates (debateStructure).</li> <li>Flexible, human-friendly plaintext syntax with minimal markup.</li> <li>Always produces valid Akoma Ntoso 3 XML, even from imperfect input.</li> <li>Provides a CLI for batch conversion and a programmatic API for pipelines, editors, and publishing workflows.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI to get both the CLI and the Python API:</p> <pre><code>pip install bluebell-akn\n</code></pre> <p>After installing, call the <code>bluebell</code> command or import <code>AkomaNtosoParser</code> from <code>bluebell.parser</code>.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#command-line","title":"Command Line","text":"<ol> <li>Create a text file with Bluebell syntax (two spaces per indent, uppercase headings, etc.):    <pre><code>cat &lt;&lt;'EOF' &gt; sample-act.txt\nCHAPTER 1 - Heading\n\n  SECTION 1 - Short title\n\n    Some introductory text.\n\n  SECTION 2\n\n    This section has two items:\n\n    ITEMS\n      ITEM (a)\n        Here is item (a) text.\n\n      ITEM (B)\n        Here is item (b) text.\nEOF\n</code></pre></li> <li>Parse it:    <pre><code>bluebell /akn/za/act/2009/1 act sample-act.txt --pretty &gt; act.xml\n</code></pre></li> </ol> <p><code>act.xml</code> now contains your act in Akoma Ntoso XML.</p>"},{"location":"#python","title":"Python","text":"<pre><code>from bluebell.parser import AkomaNtosoParser\nfrom cobalt.uri import FrbrUri\n\nfrbr_uri = FrbrUri.parse(\"/akn/za/act/2009/1\")\nparser = AkomaNtosoParser(frbr_uri)\nxml = parser.parse_to_xml(\"\"\"\nCHAPTER 1 - Heading\n\n  SECTION 1 - Short title\n\n    Some introductory text.\n\n  SECTION 2\n\n    This section has two items:\n\n    ITEMS\n      ITEM (a)\n        Here is item (a) text.\n\n      ITEM (B)\n        Here is item (b) text.\n\"\"\")\nprint(xml)\n</code></pre>"},{"location":"#where-to-next","title":"Where to Next?","text":"<ul> <li>Grammar \u2013 study the Bluebell grammar and learn the keywords each document type expects.</li> <li>Commandline Usage \u2013 run the parser on files and capture XML or JSON output.</li> <li>Library Usage \u2013 embed Bluebell in Python projects, including round-tripping text and XML.</li> <li>Troubleshooting \u2013 interpret parser errors and fix common input issues.</li> </ul>"},{"location":"advanced/","title":"Advanced Topics","text":""},{"location":"advanced/#intermediate-output-structure","title":"Intermediate output structure","text":"<p>The parser produces a dict (Python) parse tree, which is later transformed into XML. This intermediate step makes it easier to adapt the parser's output it AKN's sometimes finnicky requirements.</p> <p>You can see an example of this structure by running <code>bluebell act act.txt --json</code></p> <pre><code>{\n  type: 'type of the element, such as \"hier\", \"block\" etc.',\n  name: 'name of the element, such as \"body\", \"part\" or \"p\",\n  attribs: {\n    key1: value1,\n    key2: value2,\n  },\n  children: [],\n}\n</code></pre> <p>Valid types:</p> <ul> <li><code>element</code>: simple element</li> <li><code>hier</code>: hierarchical element</li> <li><code>block</code>: block element</li> <li><code>content</code>: content element, such as <code>p</code> or <code>listIntroduction</code></li> <li><code>inline</code>: inline element, such as <code>b</code> or <code>ref</code></li> <li><code>text</code>: plain text</li> <li><code>marker</code>: a marker element that cannot contain children, such as <code>img</code></li> </ul>"},{"location":"advanced/#children","title":"Children","text":"<p>Most elements can contain children. This is an array of elements.</p> <p>These elements cannot contain children: <code>text</code>, <code>marker</code>.</p>"},{"location":"advanced/#text-elements-text","title":"Text elements (<code>text</code>)","text":"<p>The content of a text element is in the <code>value</code> attribute.</p> <p>An element that contains a single, pure-text child, can instead have a <code>text</code> attribute containing the equivalent of the <code>value</code> attribute of the text element.</p>"},{"location":"advanced/#inline-elements-inline","title":"Inline elements (<code>inline</code>)","text":"<p>Inline elements such as <code>b</code> and <code>term</code> may have other inline or text children, or a single <code>text</code> attribute.</p>"},{"location":"advanced/#block-elements-block","title":"Block elements (<code>block</code>)","text":"<p>Block elements cannot have <code>hier</code> children.</p> <ul> <li><code>num</code>: number; inline element</li> </ul>"},{"location":"advanced/#hierarchical-elements-hier","title":"Hierarchical elements (<code>hier</code>)","text":"<ul> <li><code>heading</code>: heading element; a block element</li> <li><code>subheading</code>: subheading element; a block element</li> <li><code>num</code>: number; inline element</li> </ul>"},{"location":"advanced/#footnotes","title":"Footnotes","text":"<p>Footnotes are treated specially because they are a subflow element that appears inline. The are split into two parts: a reference to the footnote inline, and the footnote content:</p> <pre><code>This text[++FN 1++] has a footnote.\n\nFOOTNOTE 1\n\n  the content of the footnote\n</code></pre> <p>When converting the parse tree into XML, the footnote content must be inserted into the point where it is referenced. This is done by post-processing the XML. A special non-AKN <code>&lt;displaced name=\"footnote\" marker=\"1\"&gt;...&lt;/displaced&gt;</code> element is inserted in the XML where the footnote content appears. The reference to the footnote inline is an appropriate <code>authorialNote</code> element with a <code>displaced=\"footnote\"</code> attribute.</p> <p>Post-processing code then matches the <code>&lt;displaced&gt;</code> element with its <code>&lt;authorialNote&gt;</code> using the name and marker, moves the children of the <code>displaced</code> into the <code>authorialNote</code>, and removes the <code>displaced</code> element.</p>"},{"location":"advanced/#example","title":"Example","text":"<pre><code>{\n  type: 'hier',\n  name: 'chapter',\n  num: '1',\n  heading: 'Definitions and fundamental principles',\n  children: [{\n    type: 'hier',\n    name: 'section',\n    num: '1.',\n    heading: 'Definitions',\n    children: [{\n      type: 'inline',\n      name: 'p',\n      text: 'In this By-law, unless the context indicates otherwise -',\n    }, {\n      type: 'inline',\n      name: 'p',\n      text: '\"Air Quality\" means:',\n    }, {\n      type: 'block',\n      name: 'list',\n      children: [{\n        type: 'block',\n        name: 'item',\n        num: '(a)',\n        children: [{\n          type: 'inline',\n          name: 'p',\n          children: [{\n            type: 'text',\n            value: 'something with '\n          }, {\n            type: 'inline',\n            name: 'b',\n            text: 'bold',\n          }, {\n            type: 'text',\n            value: ' in it.'\n          }],\n        }],\n      }, {\n        type: 'block',\n        name: 'item',\n        num: '(b)',\n        children: [{\n          type: 'inline',\n          name: 'p',\n          children: [{\n            type: 'text',\n            value: 'text with a',\n          }, {\n            type: 'marker',\n            name: 'eol',\n          }, {\n            type: 'text',\n            value: 'newline in it.',\n          }],\n        }],\n      }],\n    }],\n  }],\n}\n</code></pre>"},{"location":"cli/","title":"Commandline Usage","text":"<p>The <code>bluebell</code> command converts plaintext files into Akoma Ntoso XML (or an intermediate JSON tree) using the same parser the library exposes.</p>"},{"location":"cli/#basic-syntax","title":"Basic Syntax","text":"<pre><code>bluebell &lt;frbr_uri&gt; &lt;root&gt; &lt;input-file&gt; [--json] [--pretty]\n</code></pre> <ul> <li><code>&lt;frbr_uri&gt;</code>: FRBR URI describing the work, e.g. <code>/akn/za/act/2009/1</code>. It is parsed with <code>cobalt.FrbrUri</code> and is   required for proper metadata in the output document.</li> <li><code>&lt;root&gt;</code>: the document type to parse (<code>act</code>, <code>bill</code>, <code>judgment</code>, <code>debateReport</code>, <code>doc</code>, <code>statement</code>, etc.). Aliases such   as <code>debatereport</code> are also recognised.</li> <li><code>&lt;input-file&gt;</code>: path to the plaintext source you want to parse.</li> <li><code>--json</code>: emit the intermediate parse tree as JSON instead of XML.</li> <li><code>--pretty</code>: pretty-print the XML output (ignored when <code>--json</code> is set).</li> </ul>"},{"location":"cli/#example","title":"Example","text":"<pre><code>bluebell /akn/za/act/2009/1 act samples/act.txt --pretty &gt; act.xml\n</code></pre> <p>The command reads <code>samples/act.txt</code>, parses it using the <code>act</code> grammar, and writes formatted Akoma Ntoso XML to STDOUT. Redirect output to capture the XML.</p>"},{"location":"cli/#error-behaviour","title":"Error Behaviour","text":"<p>If parsing fails, the CLI prints the numbered source lines to STDERR before raising the error. Use this context to locate and fix structural issues (indentation, missing headings, invalid keywords). Once the input matches the grammar, rerun the command to produce XML.</p>"},{"location":"demo/","title":"Bluebell Live Demo","text":"<p>Experiment with Bluebell text by editing the box below. The XML and HTML is updated live as you type. This uses  Pyodide to run the Bluebell parser in the browser, and styling for the HTML is apply with the Laws.Africa Law Widgets library.</p>  CHAPTER 1 - Preliminary   SEC 1. - Short title     This is some example text in section 1. It includes **bold** text and //italic// text.    SEC 2. - Second section     SUBSEC (1)       This is subsection (1) under section 2, with two sub-items.        ITEMS         ITEM (a)           First item.          ITEM (b)           Second item.    <p>Loading parser\u2026</p> XML HTML Download XML <pre>&lt;!-- XML output will appear here --&gt;</pre>"},{"location":"grammar/","title":"Grammar","text":"<p>Bluebell targets the Akoma Ntoso 3 grammar using its own well-structured plaintext format. Authors describe hierarchy with indentation and headings (think of it as \u201cMarkdown for AKN\u201d), and the parser turns that structure into Akoma Ntoso XML. Understanding the document types, structural keywords, inline markup, and footnotes will help you prepare input that round-trips cleanly.</p>"},{"location":"grammar/#document-types","title":"Document Types","text":"<p>Choose the root type that matches your document. The root determines which structural keywords are recognised and which containers must appear. Inline markup is largely shared across types, but hierarchical and block elements vary.</p> Root AKN structure Description <code>act</code>, <code>bill</code> <code>hierarchicalStructure</code> Statutes with chapters, parts, sections, etc. <code>judgment</code> <code>judgmentStructure</code> Judgments split into INTRODUCTION/BACKGROUND/etc. <code>debateReport</code> <code>openStructure</code> Hansard-style debate reports. <code>doc</code>, <code>statement</code> <code>openStructure</code> Open, lightly structured narrative documents. <code>debate</code> <code>debateStructure</code> Parliamentary debates with speech containers and groups. <p>All document types support attachments and inline markup. Acts/bills and judgments enforce stricter hierarchical rules than the open/debate structures.</p>"},{"location":"grammar/#containers-hierarchy","title":"Containers &amp; Hierarchy","text":"<p>Bluebell expresses structure through indentation: every hierarchical or block element contains indented child content. Use consistent two-space indentation for nested paragraphs, lists, tables, and speech blocks.</p>"},{"location":"grammar/#indentation-tips","title":"Indentation Tips","text":"<ol> <li>Use two spaces per indent level (tabs are converted automatically, but consistent spaces make intent clearer).</li> <li>Dedent only when closing the current container; do not skip levels.</li> <li>Ensure the file ends with a newline so trailing containers close properly.</li> </ol>"},{"location":"grammar/#preface-preamble-body-conclusions","title":"Preface, Preamble, Body, Conclusions","text":"<p>These container keywords bracket introductory and closing material:</p> <pre><code>PREFACE\n  ...\n\nPREAMBLE\n  ...\n\nBODY\n  ...\n\nCONCLUSIONS\n  ...\n</code></pre> <p><code>BODY</code> marks where the main hierarchy (sections, parts, etc.) begins. <code>CONCLUSIONS</code> is optional but recommended for closing remarks.</p>"},{"location":"grammar/#judgment-sections","title":"Judgment Sections","text":"<p>Judgment documents use labelled sections:</p> <pre><code>INTRODUCTION\nBACKGROUND\nARGUMENTS\nREMEDIES\nMOTIVATION\nDECISION\n</code></pre> <p>The order is important.</p>"},{"location":"grammar/#hierarchical-elements","title":"Hierarchical Elements","text":"<p>These keywords indicate hierarchical containers:</p> <ul> <li><code>ALINEA</code></li> <li><code>ARTICLE</code>, <code>ART</code></li> <li><code>BOOK</code></li> <li><code>CHAPTER</code>, <code>CHAP</code></li> <li><code>CLAUSE</code></li> <li><code>DIVISION</code></li> <li><code>INDENT</code></li> <li><code>LEVEL</code></li> <li><code>LIST</code></li> <li><code>PARAGRAPH</code>, <code>PARA</code></li> <li><code>PART</code></li> <li><code>POINT</code></li> <li><code>PROVISO</code></li> <li><code>RULE</code></li> <li><code>SECTION</code>, <code>SEC</code></li> <li><code>SUBCHAPTER</code>, <code>SUBCHAP</code></li> <li><code>SUBCLAUSE</code></li> <li><code>SUBDIVISION</code></li> <li><code>SUBLIST</code></li> <li><code>SUBPARAGRAPH</code>, <code>SUBPARA</code></li> <li><code>SUBPART</code></li> <li><code>SUBRULE</code></li> <li><code>SUBSECTION</code>, <code>SUBSEC</code></li> <li><code>SUBTITLE</code></li> <li><code>TITLE</code></li> <li><code>TOME</code></li> <li><code>TRANSITIONAL</code></li> </ul> <p>All AKN hierarchical containers (CHAPTER, PART, SECTION, ARTICLE, etc.) follow the same syntax:</p> <pre><code>&lt;hier&gt;&lt;attribs&gt;\n  ...\n\n&lt;hier&gt;&lt;attribs&gt;\n  SUBHEADING &lt;subheading&gt;\n  ...\n\n&lt;hier&gt;&lt;attribs&gt; &lt;num&gt;\n  ...\n\n&lt;hier&gt;&lt;attribs&gt; &lt;num&gt; - &lt;heading&gt;\n  ...\n\n&lt;hier&gt;&lt;attribs&gt; - &lt;heading&gt;\n  ...\n</code></pre> <ul> <li><code>&lt;hier&gt;</code>: uppercase keyword such as <code>CHAPTER</code>, <code>SECTION</code>, <code>PARAGRAPH</code>, or a synonym.</li> <li><code>&lt;attribs&gt;</code>: optional <code>{attr value|...}</code> block (see attributes section below).</li> <li><code>&lt;num&gt;</code>: optional number (<code>1</code>, <code>1A</code>, <code>2(bis)</code>, etc.).</li> <li><code>&lt;heading&gt;</code>: optional heading text after <code>-</code>.</li> <li><code>SUBHEADING</code> provides an optional subheading within the container.</li> </ul>"},{"location":"grammar/#crossheading","title":"Crossheading","text":"<p>Use <code>CROSSHEADING &lt;heading&gt;</code> between hierarchical elements when you need a heading but not a new container.</p>"},{"location":"grammar/#attachments","title":"Attachments","text":"<p>All document types may end with attachments (which can nest). Keywords such as <code>APPENDIX</code>, <code>SCHEDULE</code>, and <code>ANNEXURE</code> are aliases for <code>ATTACHMENT</code>.</p> <pre><code>ATTACHMENT &lt;heading&gt;\n  ...\n\nATTACHMENT &lt;heading&gt;\n  SUBHEADING &lt;subheading&gt;\n  ...\n</code></pre>"},{"location":"grammar/#block-elements","title":"Block Elements","text":"<p>Block elements indicate structure within sections and also rely on indentation.</p>"},{"location":"grammar/#numbered-lists","title":"Numbered Lists","text":"<pre><code>ITEMS\n  introductory text\n\n  ITEM (a)\n    ...\n\n  ITEM (b) - Heading\n    SUBHEADING Subheading\n    ...\n</code></pre>"},{"location":"grammar/#bulleted-lists","title":"Bulleted Lists","text":"<pre><code>BULLETS\n  * Item 1\n  * Item 2 spanning\n    multiple lines\n</code></pre>"},{"location":"grammar/#block-quotes","title":"Block Quotes","text":"<pre><code>QUOTE{startQuote \"}\n  Quoted material\n</code></pre>"},{"location":"grammar/#tables","title":"Tables","text":"<pre><code>TABLE.class-name\n  TR\n    TH{colspan 2}\n      Heading cell\n    TC\n      Cell text\n</code></pre>"},{"location":"grammar/#longtitle","title":"Longtitle","text":"<pre><code>LONGTITLE The long title of an Act\n</code></pre>"},{"location":"grammar/#inline-markup","title":"Inline Markup","text":"<p>Apart from a few shorthand formats (<code>**bold**</code>, <code>//italics//</code>, <code>__underline__</code>, <code>{{^superscript}}</code>, <code>{{_subscript}}</code>), inline markup uses <code>{{ ... }}</code> blocks. Nest inline elements freely within paragraphs, headings, and list items.</p>"},{"location":"grammar/#abbreviations","title":"Abbreviations","text":"<pre><code>{{abbr{title Akoma Ntoso} AKN}}\n</code></pre>"},{"location":"grammar/#editorial-remarks","title":"Editorial Remarks","text":"<pre><code>{{*remark content}}\n\nA {{*remark may\nspan multiple lines.}}\n</code></pre>"},{"location":"grammar/#emphasis","title":"Emphasis","text":"<pre><code>{{em{type strong} Important text}}\n</code></pre>"},{"location":"grammar/#images","title":"Images","text":"<pre><code>{{IMG /images/figure.png Figure description}}\n</code></pre>"},{"location":"grammar/#references-links","title":"References (Links)","text":"<pre><code>{{&gt;https://example.com link text}}\n</code></pre>"},{"location":"grammar/#terms","title":"Terms","text":"<pre><code>{{term{refersTo #definition-term} defined term}}\n</code></pre>"},{"location":"grammar/#generic-inline-elements","title":"Generic Inline Elements","text":"<pre><code>{{inline{name custom} text}}\n</code></pre>"},{"location":"grammar/#footnotes","title":"Footnotes","text":"<p>Footnotes use two parts: an inline marker and a matching <code>FOOTNOTE</code> block at the same indent level.</p> <pre><code>This sentence includes the {{^{{FOOTNOTE *}}}} marker.\n\nFOOTNOTE *\n  This is the footnote content.\n</code></pre> <ul> <li>The marker is <code>{{FOOTNOTE &lt;symbol&gt;}}</code>, often wrapped in superscript (<code>{{^...}}</code>).</li> <li>The block must appear immediately after the paragraph (no indentation change) and reuse the same symbol.</li> <li>Footnotes can contain block and inline markup just like body content.</li> </ul>"},{"location":"grammar/#attributes","title":"Attributes","text":"<p>Any element that accepts attributes can use <code>{name value|name2 value2}</code> immediately after the keyword. Class attributes can be written with dot notation preceding the attribute block.</p> <pre><code>SECTION.class-one.class-two{status amended}\n  ...\n</code></pre> <p>This is equivalent to <code>{class class-one class-two|status amended}</code>.</p>"},{"location":"grammar/#example-act-snippet","title":"Example Act Snippet","text":"<pre><code>PREFACE\n  This is in the preface\n\nPREAMBLE\n  This is in the preamble\n\nBODY\n\nIntroductory text in the body.\n\nSECTION 1.\n  Text in section one, with some list items:\n\n  SUBSECTION (a)\n    cheese\n\n  SUBSECTION (b)\n    fish, both:\n\n    SUBSECTION (i)\n      fresh, and\n\n    SUBSECTION (ii)\n      tinned.\n\nPART 1 - The First Part\n  SUBHEADING Very exciting\n\n  SECTION 2.\n    This is the second section inside part 1.\n\nSCHEDULE - First Schedule\n  SUBHEADING With a subheading\n\n  Text of the schedule\n</code></pre>"},{"location":"grammar/#practical-tips","title":"Practical Tips","text":"<ul> <li>Keywords are uppercase to avoid clashing with body text.</li> <li>When in doubt, inspect the generated XML to confirm the hierarchy and headings appear as expected.</li> <li>If Bluebell encounters unknown constructs, it keeps the text so you can edit and re-run the parser.</li> </ul>"},{"location":"library/","title":"Library Usage","text":"<p>Import <code>AkomaNtosoParser</code> when you need to integrate Bluebell into pipelines, web apps, or editors.</p> <pre><code>from bluebell.parser import AkomaNtosoParser\nfrom cobalt.uri import FrbrUri\n\nfrbr_uri = FrbrUri.parse(\"/akn/za/act/2009/1\")\nparser = AkomaNtosoParser(frbr_uri)\nxml = parser.parse_to_xml(source_text, \"act\")\n</code></pre>"},{"location":"library/#creating-a-parser","title":"Creating a Parser","text":"<pre><code>parser = AkomaNtosoParser(frbr_uri, eid_prefix=\"example\")\n</code></pre> <ul> <li><code>frbr_uri</code> must be a <code>cobalt.FrbrUri</code> describing the work you are converting.</li> <li><code>eid_prefix</code> is optional and lets you customise automatically generated <code>eId</code> values in the XML.</li> </ul>"},{"location":"library/#parsing-text","title":"Parsing Text","text":"<p>Use the convenience method to go straight to XML:</p> <pre><code>xml_element = parser.parse_to_xml(text, root)\n</code></pre> <ul> <li><code>text</code>: Unicode string containing the document body.</li> <li><code>root</code>: grammar root (<code>act</code>, <code>bill</code>, <code>judgment</code>, <code>debateReport</code>, <code>doc</code>, <code>statement</code>, etc.). Aliases like   <code>debatereport</code> resolve automatically.</li> </ul> <p>If you only need the intermediate parse tree (for custom transformations) call <code>parse(text, root)</code>. The CLI uses this path before converting the tree to XML or JSON.</p>"},{"location":"library/#handling-errors","title":"Handling Errors","text":"<p><code>parser.parse</code> and <code>parser.parse_to_xml</code> raise <code>bluebell.akn.ParseError</code> when the text violates the grammar. Catch it to provide user-friendly feedback:</p> <pre><code>from bluebell.akn import ParseError\n\ntry:\n    xml = parser.parse_to_xml(text, \"act\")\nexcept ParseError as exc:\n    print(exc)  # includes the failure line and expected tokens\n</code></pre>"},{"location":"library/#converting-xml-back-to-text","title":"Converting XML Back to Text","text":"<p><code>AkomaNtosoParser.unparse(xml)</code> applies the built-in XSLT (<code>bluebell/akn_text.xsl</code>) to generate editable text from an Akoma Ntoso document or fragment:</p> <pre><code>with open(\"act.xml\") as fh:\n    text = parser.unparse(fh.read())\n</code></pre> <p>This is useful for round-tripping content through Bluebell\u2014parse user-edited text to XML, process it, and later turn the XML back into a text representation for further editing.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Use these checks when the parser raises errors or emits unexpected XML.</p>"},{"location":"troubleshooting/#parseerror-messages","title":"ParseError Messages","text":"<p><code>ParseError</code> includes the failing line number and the tokens the grammar expected next. Typical causes:</p> <ul> <li>Unknown keyword: a heading that does not match the grammar (typo, lowercase, unsupported synonym).</li> <li>Indent mismatch: nested content not indented with two spaces, or tabs sneaking into the text.</li> <li>Unexpected EOF: the file lacks a trailing newline or an unclosed structure.</li> </ul> <p>Fix the offending line and rerun the CLI or your integration to verify the change.</p>"},{"location":"troubleshooting/#verify-the-root-type","title":"Verify the Root Type","text":"<p>Ensure the <code>root</code> argument matches the document you are parsing. Using <code>act</code> for a judgment (or vice versa) can lead to missing elements or outright failures. Lowercase aliases such as <code>debatereport</code> are automatically capitalised, but other misspellings are not.</p>"},{"location":"troubleshooting/#inspect-intermediate-output","title":"Inspect Intermediate Output","text":"<p>When debugging, the CLI can emit the parse tree as JSON:</p> <pre><code>bluebell /akn/za/act/2009/1 act sample.txt --json | jq .\n</code></pre> <p>This reveals how headings and paragraphs were recognised before converting to XML.</p>"},{"location":"troubleshooting/#round-trip-to-text","title":"Round-Trip to Text","text":"<p>If you have XML produced elsewhere and want to see how Bluebell would express it as text, use <code>AkomaNtosoParser.unparse</code> to generate editable plaintext. Comparing that output to your source can highlight structural differences you need to address.</p>"}]}